# SSL证书相关

## 证书工作原理

一般证书分有三类，根证书、服务器证书和客户端证书。根证书，是生成服务器证书和客户端证书的基础，是信任的源头，也可以叫自签发证书，即CA证书。服务器证书，由根证书签发，配置在服务器上的证书。客户端证书，由根证书签发，配置在服务器上，并发送给客户，让客户安装在浏览器里的证书。

### CA

CA(Certificate Authority)是证书的签发机构，它是负责管理和签发证书的第三方机构，是受到广泛信任的机构。一般在我们的电脑中，浏览器里，或者手机里都会内置一批这样的受信机构的根证书。

 

### 证书信任链

比如我是CA机构我签发了一封证书 我这份证书是信任B证书的另外B证书又信任了其他的C证书......那么这条链条下去的都可以信任。所以一旦CA机构的根证书不可信了，那么所有由他签发出来的证书将全部变得不可信，后果很严重。

 

### 公钥密码体制

公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：

- 加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。 
- 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。

公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。

 

### CA证书

顾名思义CA证书就是由CA机构签发的证书。其实证书谁都可以签，你也可以自己给自己签发证书，但是由于你自己并不是被广泛信任的机构，所以你自己签发的证书并没有什么用。公网也不会信任你的证书。服务器证书包括以下几种信息：

> - 证书的发布机构 
> - 证书的有效期 
> - 公钥 
> - 证书所有者（Subject） 
> - 签名所使用的算法 
> - 指纹以及指纹算法
>
> ◆Issuer (证书的发布机构)
>
> 指出是什么机构发布的这个证书，也就是指明这个证书是哪个公司创建的(只是创建证书，不是指证书的使用者)。对于上面的这个证书来说，就是指"SecureTrust CA"这个机构。
>
>  
>
> ◆Valid from , Valid to (证书的有效期)
>
> 也就是证书的有效时间，或者说证书的使用期限。 过了有效期限，证书就会作废，不能使用了。
>
>  
>
> ◆Public key (公钥)
>
> 这个我们在前面介绍公钥密码体制时介绍过，公钥是用来对消息进行加密的，第2章的例子中经常用到的。这个数字证书的公钥是2048位的，它的值可以在图的中间的那个对话框中看得到，是很长的一串数字。
>
>  
>
> ◆Subject (主题)
>
> 这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 对于这里的证书来说，证书的所有者是Trustwave这个公司。
>
>  
>
> ◆Signature algorithm (签名所使用的算法)
>
> 就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名。
>
>  
>
> ◆Thumbprint, Thumbprint algorithm (指纹以及指纹算法)
>
> 这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。  其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。  注意，这个指纹会使用"CA"证书机构的私钥用签名算法(Signature algorithm)加密后和证书放在一起。

 

### CA如何给我们签发一个有效证书

> 举个例子方便大家理解，假设我们公司"ABC Company"花了1000块钱，向一个证书发布机构"SecureTrust  CA"为我们自己的公司"ABC Company"申请了一张证书，注意，这个证书发布机构"SecureTrust  CA"是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了"SecureTrust  CA"的证书。"SecureTrust CA"在给我们发布证书时，把Issuer,Public key,Subject,Valid  from,Valid  to等信息以明文的形式写到证书里面，然后用一个指纹算法计算出这些数字证书内容的一个指纹，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布，同时"SecureTrust  CA"还会给一个我们公司"ABC Company"的私钥给到我们。我们花了1000块钱买的这个证书的内容如下：
>
> ×××××××××××××××证书内容开始×××××××××××××××××
>
> Issuer : SecureTrust CA
>
> Subject : ABC Company
>
> Valid from ： 某个日期
>
> Valid to： 某个日期
>
> Public Key : 一串很长的数字
>
> …… 其它的一些证书内容……
>
> {证书的指纹和计算指纹所使用的指纹算法}[SecureTrust CA的私钥|RSA]      //这个就是"SecureTrust  CA"对这个证书的一个数字签名，表示这个证书确实是他发布的，有什么问题他会负责(收了我们1000块，出了问题肯定要负责任的)

 

所以最后在我们使用https的时候究竟发生了什么：

![img](E:\MyStudy\LinuxStudy\pictures\742678-20161204233935881-538260881.png)

结合上面这个图我一步一步讲解：

1、客户端向一个需要https访问的网站发起请求。

2、服务器将证书发送给客户端进行校验。证书里面包含了其公钥。这里要特别说一下客户端到底 如何来校验对方发过来的数字证书是否有效。

> 1. 首先在本地电脑寻找是否有这个服务器证书上的ca机构的根证书。如果有继续下一步，如果没有弹出警告。
>
> 2. 使用ca机构根证书的公钥对服务器证书的指纹和指纹算法进行解密。
>
> 3. 得到指纹算法之后，拿着这个指纹算法对服务器证书的摘要进行计算得到指纹。
>
> 4. 将计算出的指纹和从服务器证书中解密出的指纹对比看是否一样如果一样则通过认证。
>
>    

3、校验成功之后，客户端会生成一个随机串然后使用服务器证书的公钥进行加密之后发送给服务器。

4、服务器通过使用自己的私钥解密得到这个随机值。

5、 服务器从此开始使用这个随机值进行对称加密开始和客户端进行通信。

6、客户端拿到值用对称加密方式 使用随机值进行解密。

 

为什么不一直使用非对称进行加密，而是在类似握手之后开始使用对称加密算法进行https通信：

非对称加密的消耗和所需的计算以及时间远比对称加密消耗要大，所以在握手和认证之后，服务器和客户端就开始按照约定的随机串，对后续的数据传输进行加密。

## 自签ssl证书

### 签发CA证书

#### 查看openssl的配置文件openssl.cnf的存放位置

```
openssl version -a
```

![img](E:\MyStudy\LinuxStudy\pictures\2018082817114455.png)

#### 查看openssl的配置文件openssl.cnf，因为配置文件中对证书的名称和存放位置等相关信息都做了定义。

```
vim /etc/pki/tls/openssl.cnf
```

![img](E:\MyStudy\LinuxStudy\pictures\201808281715042.png)

![img](E:\MyStudy\LinuxStudy\pictures\20180828171547422.png)

#### 为根证书CA创建所需的目录及文件

```shell
cd /etc/pki/CA
 
#没有就自己创建，有就不必了
mkdir -pv {certs,crl,newcerts,private}
touch {serial,index.txt}
```

#### 指明证书的开始编号

```shell
echo 01 >> serial
```

#### 生成根证书的私钥

```shell
openssl genrsa -out private/cakey.pem 2048
```

#### 生成根证书CA，根证书的存放位置也要与配置文件中的设置相匹配，生成证书时需要填写相应的信息。

```shell
openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out cacert.pem -days 365
```

![img](E:\MyStudy\LinuxStudy\pictures\20180828175757594.png)

```shelll
Country Name (2 letter code) []:CN                        // 输入国家代码，中国填写 CN
State or Province Name (full name) []:HangZhou            // 输入省份，这里填写 HangZhou
Locality Name (eg, city) []:HangZhou                      // 输入城市，我们这里也填写 HangZhou
Organization Name (eg, company) []:tbj                    // 输入组织机构(或公司名，我这里随便写个tbj)
Organizational Unit Name (eg, section) []:tbj             // 输入机构部门
Common Name (eg, fully qualified host name) []:*.abc.com  // 输入域名，我这边是 (*.abc.com)  
Email Address []:tugenhua0707@qq.com                      // 你的邮箱地址

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:123456                            // 你的证书密码，如果不想设置密码，可以直接回车
```

至此，根证书就签好了

### 用根证书来签发证书

#### 生成私钥

```shell
openssl genrsa -out server.key 2048
```

#### 生成请求文件

```shell
openssl req -new -key server.key -out server.csr -days 365
```

![img](E:\MyStudy\LinuxStudy\pictures\20180828200342944.png)

#### 用根证书来签发证书

```bash
openssl ca -in server.csr -out server.crt -days 365
```

